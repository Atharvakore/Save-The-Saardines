@startuml
'General
package GeneralEnums {
  enum Direction {
    D0,
    D60,
    D120,
    D180,
    D240,
    D300
  }

  enum GarbageType {
    OIL,
    PLASTIC,
    CHEMICALS
  }
}




TasksRewards.Task --o Corporation

class Corporation {
  - id:Int,
  ' Garbage of the corporation that we have cooperated with.
  ' I.e. past locations of garbage as a mapping int (id) -> vec2d.
  - partnerGarbage: Map<Int, Vec2D>
  - name:String,
  - acceptedGarbageTypes: List<GarbageType>
  - ownedHarbors: List<Shore>
  - ownedShips: List<Ship>
  - tasks: List<Task>
  ' Garbage that has trackers owned by this corporation.
  - trackedGarbage: List<Garbage>
  - lastCoordinatingCorporation: Corporation
  + cooperateWith(c1: Corporation): Unit
  + run(sea: Sea, otherShips: List<Ship>): Unit
  + getActiveTasks(): List<Task>
  - moveShips(sea: Sea): Unit
  - collectGarbage(sea: Sea): Unit
  - refuelAndUnloadShips(sea: Sea): Unit
  - getShipsOnHarbor(): Boolean
  - findClosestShip(sourceMap: Map<Tile, List<Tile>>, ships: List<Ship>) : List<Tile>
  - findClosestHarbor(sourceMap: Map<Tile, List<Tile>>, ships: List<Shore>) : List<Tile>
  - filterCollectingShips(): List<Ship>
  - filterScoutingShips(): List<Ship>
  - filterCoordinatingShips(): List<Ship>

}
Tiles.Shore --o Corporation
class Dijkstra {
  ' Returns a mapping that, for each path from the source to destination
  ' tiles, maps the destination tile to the path.
  + execute(source: Tile): Map<Tile,List<Tile>>
}

Dijkstra --o Simulation
Tiles.Tile --o Tiles.Sea

class Main {
 + main(mapFile : String, corporationsFile: String, scenarioFile: String, max_ticks: Int)
 - parse(): Accumulator
}

Main -- Simulation

Events.Event --o Simulation
Ships.Ship --o Corporation

Loggers.Logger --o Main
Parser.JSONParser --o Main
Tiles.Vec2D --o Tiles.Sea
Tiles.Vec2D --o Tiles.Tile



class Simulation {
  - corporations: List<Corporation>
  - allEvents: List<Event>
  - tick: Int
  - maxTick: Int
  - map: Sea
  + start(): Unit
  + tick(): Unit
  - runCorporations(): Unit
  - driftGarbage(): Unit
  - driftShips(): Unit
  - processEvents(): Unit
}

Corporation --o Simulation
Tiles.Sea --o Simulation


package Events {
  abstract class Event {
    - id: Int,
    - fireTick: Int,
    ' Returns bool whether it the event is finished and can be removed
    ' from consideration in future ticks.
    + abstract actUponTick(currentTick: Int): Boolean
  }

  Pirate_Attack --|> Event
  class Pirate_Attack {
    - ship: Ship,
    - owningCorporation: Corporation,
    + override actUponTick(currentTick: Int): Boolean
  }

  Local_Event --|> Event
  abstract class Local_Event {
    - map: Sea,
    - location: Tile,
    - radius: Int,
  }

  Storm --|> Local_Event
  class Storm {
    - speed: Int,
    - direction: Direction,
    + override actUponTick(currentTick: Int): Boolean
  }

  OilSpill --|> Local_Event
  class OilSpill {
    - amount: Int,
    + override actUponTick(currentTick: Int): Boolean
  }

  ' Parser creates a restriction class, which does not rollback anything.
  ' Then it creates endrestriction class that fires 'duration' later
  ' and rollbacks the changes.
  Restriction --|> Local_Event
  class Restriction {
    - duration: Int,
    + override actUponTick(currentTick: Int): Boolean
  }

  EndRestriction --|> Local_Event
  class EndRestriction {
    + override actUponTick(currentTick: Int): Boolean
  }
}

package Parser {
  enum TileCategory {
    SHORE,
    SHALLOW_OCEAN,
    DEEP_OCEAN
  }

  interface JSONParser {
    - logger: Logger
    - accumulator: Accumulator
  }

  MapJSONParser --|> JSONParser
  class MapJSONParser {
    + parseMap(jsonFile: String): Boolean
    - createTileObjects(filePath: String): List<JSONObject>
    - validateTiles(objects: List<JSONObject>): Boolean
    - validateTile(tile: JSONObject): Boolean
'    - validateUniqueId(id: Int): Boolean
'    - validateCoordinates(coord: Vec2D): Boolean
'    - validateRequirements(tileObject: JSONObject): Boolean
    - createTile(tile:JSONObject):Tile
    - createMap():Sea
  }

  class CorporationJSONParser{
    +CorporationJSONParser(accumulator:Accumulator): ScenarioJSONParser
    +parseCorporations(filePath: String): Boolean
    +parseShips(filePath: String): Boolean

    - createCorporationObjects(filePath: String): List<JSONObject>
    -validateCorporations(corpObjects: List<JSONObject>): Boolean
    -validateCorporation(corporationObject: JSONObject): Boolean

'    -validateCorporationUniqueId(id: Int): Boolean
'    -validateCorporationUniqueName(name: String): Boolean
'    -validateHarborTiles(harbors: List<Int>): Boolean
'    -validateCorporationGarbageTypes(g: List<GarbageType>): Boolean
'    -validateCorporationShip(ships: List<Int>): Boolean

    - createShipObjects(filePath: String): List<JSONObject>
    - createShip(ship: JSONObject): Ship
    - createCorporation(corporation: JSONObject): Corporation
    - validateShips(ships: List<JSONObject>):Boolean
    - validateShip(ship:JSONObject): Boolean
'    - validateShipUniqueId(id:Int): Boolean
'    - validateShipUniqueName(name:String): Boolean
'    - validateShipLocation(location: Int): Boolean
'    - validateShipAttributes(ship:JSONObject): Boolean
  }

  class ScenarioJSONParser{

    + ScenarioJSONParser(accumulator:Accumulator):ScenarioJSONParser
    + parseEvents(EventJSON: String): Boolean
    + parseGarbage(garbageJSON: String): Boolean
    +parseTasks(taskJSON: String): Boolean
    +parseRewards(rewardJSON: String): Boolean

    - validateGarbages(garbages:List<JSONObject>): Boolean
    - validateGarbage(garbage: JSONObject): Boolean
    - validateEvents(events:List<JSONObject>): Boolean
    - validateEvent(event: JSONObject): Boolean
    - validateTasks(tasks: List<JSONObject>): Boolean
    - validateTask(task: JSONObject): Boolean
    - validateRewards(rewards: List<JSONObject>): Boolean
    - validateReward(reward: JSONObject): Boolean
    - createGarbage(garbage: JSONObject): Garbage
    - createEvent(event: JSONObject): Event
    - createReward(reward: JSONObject): Reward
    - createTask(task: JSONObject): Task

'    - validateGarbageUniqueId(): Boolean
'    - validateGarbageType(): Boolean
'    - validateGarbageLocationExists(): Boolean
'    - validateGarbageAmount(): Boolean

'    - validateEventUniqueId(): Boolean
'    - validateEventType(): Boolean
'    - validateEventTick(): Boolean
'    - validateEventLocation(): Boolean
'    - validateEventRadius(): Boolean
'    - validateEventSpeed(): Boolean
'    - validateEventAmountIfExists(): Boolean
'    - validateEventDirectionIfExists(): Boolean
'    - validateEventShipIdIfExists(): Boolean

  }

  JSONParser <|-- CorporationJSONParser
  JSONParser <|-- ScenarioJSONParser
  Accumulator --o JSONParser
  class Accumulator {
    + map: Sea
    + corporations: Map<Int, Corporation>
    + ships: Map<Int, Ship>
    + events: Map<Int, Event>
    + garbage: Map<Int, Garbage>
    + tasks: Map<Int, Task>
    + rewards: Map<Int, Reward>
    + mapCorporationToHarbor: Map<Int, List<Tile>>
    + mapCorporationToShips: Map<Int, List<Int>>

    + getHarborsOfCorporation(corporationId: Int): List<Tile>
    + getShipsIDofCorporation(corporationId: Int): List<Int>
    + getTileFromMap(tileId: Int): Tile
    + getRewardById(rewardId: Int): Reward
    + getTaskById(taskId: Int): Task
    + getTileFromMap(tileCoordinates:Vec2D): Tile
    + addTile(id: Int, t: Tile): Unit
    + addTileByCoordinates(coord: Vec2D, t: Tile): Unit
    + addShip(shipId: Int, ship: Ship)
    + addShipToCorp(corporationId: Int, shipId: Int)
    + getShipsOfCorp(corpId: Int): List<Int>
    + addEvent(eventId: Int, event: Event)
    + addCorporation(corpId: Int, corporation: Corporation)
    + addGarbage(garbageId: Int, garbage: Garbage)
  }
}

package Tiles {
  class Vec2D {
    + posX: Int,
    + posY: Int,
    + tilesInRadius(visibleRadius: Int): Iterator<Vec2D>
  }

  class Sea {
    + tiles: List<Tile>
    + tileIndex: Map<Vec2D, Tile>
    + getTileById(tile_id: Int): Tile
    + getTileByPos(position: Vec2D): Tile
  }

  abstract class Tile {
    - id: Int
    - pos: Vec2D
    - adjacentTiles: Tile[6]
    - shipTraversable: Boolean
    - garbage: List<Garbage>
    ' Stores the amount of garbage drifted from this tile this tick.
    ' This is important because the garbage drifts to the next tile
    ' and we want to drift only as much as the current allows,
    ' but on the other hand we don't want to drift garbage twice.
    ' So we drift each piece of garbage instead of drifting from
    ' within the tick, and this field actually stores the amount
    ' to make sure that we don't drift more than the capacity
    + amountOfGarbageDriftedThisTick: Int
    + Tile(id: Int, pos: Vec2D, shipTraversable: Boolean): Tile
    + isSpaceAvailable(amount: Int): Boolean
    + driftGarbage(garbage: GarbageType, Int): Unit
    + getTileInDirection(distance: Int, dir: Direction): Tile
    + addGarbage(garbage: Garbage): Unit
    + isOilPresent(): Boolean
    + isPlasticPresent(): Boolean
    + areChemicalsPresent(): Boolean
    + getGarbageByType(types: List<GarbageType>): List<Garbage>
  }

  Garbage o--o Corporation
  class Garbage {
    - id: Int,
    - amount: Int,
    - type: GarbageType,
    - static maxId: Int,
    - trackedBy: Set<Corporation>
    + drift(currentTile: Tile): Unit
    + static getNextId(): Int
    + canDriftAtOnce(amount: Int): Boolean
    + removeAmount(amount: Int): Unit
  }

  Garbage --o Tile
  Shore --|> Tile
  DeepOcean --|> Tile
  ShallowOcean --|> Tile
  class Current {
    - speed: Int,
    - direction: Direction,
    - intensity: Int,
    + getSpeed(): Int
    + getIntensity(): Int
    + getDirection(): Direction
  }
  class Shore {
    + hasHarbor: boolean
  }

  class ShallowOcean {
  }

  class DeepOcean {
    - current: Current?
    + getCurrent(): Current?
  }
  Current --o DeepOcean
}
GeneralEnums.GarbageType --o Tiles.Garbage
GeneralEnums.Direction --o Tiles.Current


'Ships
package Ships {
  ShipCapability --o Ships.Ship
  abstract class Ship {
    - id: Int,
    - name: String,
    - owner: Corporation,
    - pos: Tile,
    - maxVelocity: Int,
    - acceleration: Int,
    - fuelCapacity: Int,
    - fuelConsumption: Int,
    - capabilities: List<ShipCapability>
    + refuel(): Unit
    + drift(): Unit
    + setTile(destination: Tile): Unit
    + isFuelSufficient(pathLength: Int): Boolean
    + addCapability(capability: ShipCapability): Unit
    - reversePath(path: List<Tile>) : List<Tile>
  }

  interface ShipCapability {
  }

  Container --o CollectingShip
  class Container {
    - garbageType: GarbageType
    - capacity: Int
  }

  ScoutingShip --|> ShipCapability
  CoordinatingShip --|> ShipCapability
  CollectingShip --|> ShipCapability
  ShipWithTracker --|> ShipCapability

  class ScoutingShip {
    ' Telescope just increments te visibleRange.
    - visibleRange: Int
    + getTilesWithGarbageInFoV(Sea): List<Tile>
  }
  class CoordinatingShip {
    - visibleRange: Int,
    ' getImmediateTilesWithGarbage()?
    + getTilesWithGarbageInFoV(Sea): List<Tile>
  }

  GarbageType --o CollectingShip
  class CollectingShip {
    - garbageType: Set<GarbageType>
    - garbageCapacity: Int,
    - garbageLoad: Int,
    - auxiliaryContainers: List<Container>
    + giveGarbage(): Unit
    + hasGarbageCapacity(garbageOnTile: List<Garbage>): Boolean
  }

  class ShipWithTracker {
  }
}

package TasksRewards {
  Task --|> Event
  abstract class Task {
    - tick: Int
    - id: Int
    - taskShip: Ship
    - reward: Reward
    - rewardShip: Ship
    - corporation: Corporation
    + checkCondition(): Boolean
  }
  'this is just an initial thought, still to be finalized
  CollectGarbageTask --|> Task
  ExploreMapTask --|> Task
  FindGarbageTask --|> Task
  CooperateTask --|> Task
  class CollectGarbageTask {
    - tile: Tile
    + override actUponTick(currentTick: Int): Boolean
  }
  class ExploreMapTask {
    - tile: Tile
    + override actUponTick(currentTick: Int): Boolean
  }
  class FindGarbageTask {
    - tile: Tile
    + override actUponTick(currentTick: Int): Boolean
  }
  class CooperateTask {
    - tile: Tile
    - otherCorporation: Corporation
    + override actUponTick(currentTick: Int): Boolean
  }
  TelescopeReward --|> Reward
  ContainerReward --|> Reward
  RadioReward --|> Reward
  TrackerReward --|> Reward
  abstract class Reward {
    - id: Int
    + abstract applyReward(ship: Ship): Unit
  }
  ScoutingShip --o TelescopeReward
  CollectingShip --o ContainerReward
  CoordinatingShip --o RadioReward
  ShipWithTracker --o TrackerReward
  class TelescopeReward {
    - additiveFieldOfView: Int
    - capability: ScoutingShip
    + override applyReward(ship: Ship): Unit
  }
  class ContainerReward {
    - capacity: Int
    - typeOfGarbage: GarbageType
    - capability: CollectingShip
    + override applyReward(ship: Ship): Unit
  }
  class RadioReward {
    - capability: CoordinatingShip
    + override applyReward(ship: Ship): Unit
  }
  class TrackerReward {
    - capability: ShipWithTracker
    + override applyReward(ship: Ship): Unit
  }
}


package Loggers {
  class Logger {
    ' - writer: PrintWriter = new PrintWriter(System.out)
    - writer: PrintWriter
    + logInitializationInfoSuccess(filename:String): Unit
    + logInitializationInfoFail(filename:String): Unit
    + logSimulationStarted(): Unit
    + logSimulationEnded(): Unit
    + logSimulationTick(tick:Int): Unit
    + logCorporationStartMoveShips(corporationId:Int): Unit
    + logShipMovement(shipId:Int,speed:Int,tileId:Int): Unit
    + logCorporationStartCollectGarbage(corporateId): Unit
    + logGarbageCollectionByShip(shipId:Int,garbageType:GarbageType,garbageId:Int): Unit
    + logCorporationCooperationStart(corporationId:Int): Unit
    + logCooperationBetweenCorporations(corporationId:Int, otherCorporationId: Int, shipId:Int, cooperatedShipId: Int): Unit
    + logCorporationRefueling(corporationId:Int): Unit
    + logRefuelingShip(shipId:Int, tileId: Int): Unit
    + logUnloadShip(shipId:Int, amount:Int, garbageType:GarbageType, tileId:Int): Unit
    + logCorporationFinishedActions(corporationId:Int): Unit
    + logCurrentDriftGarbage(garbageType:GarbageType, garbageId:Int, amount:Int, startTileId:Int, endTileId:Int): Unit
    + logCurrentDriftShip(shipId:Int,startTileId:Int, endTileId:Int): Unit
    + logEventStart(eventId:Int,eventType:EventType): Unit
    + logSimulationStatisticsCalculated(): Unit
    + logSimulationStatistics(): Unit
  }
}
@enduml