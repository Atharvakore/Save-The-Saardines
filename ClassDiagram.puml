@startuml
'General
package GeneralEnums{
  enum Direction{
    D0,
    D60,
    D120,
    D180,
    D240,
    D300
  }
  enum GarbageType{
    OIL,
    PLASTIC,
    CHEMICALS
  }
}
class Corporation {
  - id:Int,
  - partner:Corporation
  - name:String,
  - acceptedGarbageTypes: List<GarbageType>
  - ownedHarbors: List<Harbor>
  - ownedShips: List<Ship>
  - moveShips(Map): Unit
  - collectGarbage(Map): Unit
  - refuelShips(Map): Unit
  - unloadShips(Map): Unit
  +cooperateWith(c1:Corporation): Unit
  +run(Map): Unit


}
class Dijkstra{
  ' Returns a mapping that, for each path from the source to destination
  ' tiles, maps the destination tile to the path.
  + execute(Tile): Map<Tile,List<Tile>>
}

Dijkstra --o Simulation



Main o-- Parser


Tiles.Tile --o Tiles.Sea


class Main {
 - parse(): Accumulator
 + main(mapFile : String, corporationsFile: String, scenarioFile: String, max_ticks: Int)

}
Main -- Simulation


Events.Event --o Simulation
Ships.Ship --o Corporation
Tiles.Tile --o Tiles.Sea
Loggers.Logger --o Main
Parser.JSONParser --o Main
Tiles.Vec2D --o Tiles.Sea
Tiles.Vec2D --o Tiles.Tile




class Simulation {
  - corporations: List<Corporation>
  - allEvents: List<Event>
  - tick: Int
  - maxTick: Int
  - map: Sea
  - runCorporations(): Unit
  - processEvents(): Unit
  + start(): Unit
  + tick(): Unit
}
Corporation --o Simulation
Tiles.Sea --o Simulation
package Events{
  abstract class Event {
    - id: Int,
    - fireTick: Int,
    ' Returns bool whether it the event is finished and can be removed
    ' from consideration in future ticks.
    + abstract actUponTick(Int): Boolean
  }
  Pirate_Attack --|> Event
  class Pirate_Attack {
    - ship: Ship,
    - owningCorporation: Corporation,
    + override actUponTick(Int): Boolean
  }
  Local_Event --|> Event
  abstract class Local_Event {
    - map: Sea,
    - location: Tile,
    - radius: Int,
  }
  Storm --|> Local_Event
  class Storm {
    - speed: Int,
    - direction: Direction,
    + override actUponTick(Int): Boolean
  }
  OilSpill --|> Local_Event
  class OilSpill {
    - amount: Int,
    + override actUponTick(Int): Boolean
  }
  ' Parser creates a restriction class, which does not rollback anything.
  ' Then it creates endrestriction class that fires 'duration' later
  ' and rollbacks the changes.
  Restriction --|> Local_Event
  class Restriction {
    + override actUponTick(Int): Boolean
  }
  EndRestriction --|> Local_Event
  class EndRestriction {
    + override actUponTick(Int): Boolean
  }
}
package Parser {
  enum TileCategory {
    SHORE,
    SHALLOW_OCEAN,
    DEEP_OCEAN
  }
  interface JSONParser{
    - logger: Logger
    - accumulator: Accumulator
    # validateObjects(object:List<JSONObject>)
  }

  MapJSONParser --|> JSONParser


  class MapJSONParser {

    + parseMap(jsonFile:String): Boolean
    - createTileObjects(filePath: String): List<JSONObject>
    - validateTiles(objects: List<JSONObject>): Boolean
    - validateTile(tile: JSONObject): Boolean
    - validateUniqueId(id: Int): Boolean
    - validateCoordinates(coord: Vec2D): Boolean
    - validateRequirements(tileObject: JSONObject): Boolean

  }

  class CorporationJSONParser{
    +CorporationJSONParser(accumulator:Accumulator)
    +parseCorporations(filePath: String): Boolean
    +parseShips(filePath: String): Boolean

    - createCorporationObjects(file: String): List<JSONObject>
    -validateCorporations(corpObjects: List<JSONObject>): Boolean
    -validateCorporation(corporationObject: JSONObject): Boolean
    -validateCorporationUniqueId(id: Int): Boolean
    -validateCorporationUniqueName(name: String): Boolean
    -validateHarborTiles(harbors: List<Int>): Boolean
    -validateCorporationGarbageTypes(g: List<GarbageType>): Boolean
    -validateCorporationShip(ships: List<Int>): Boolean

    - createShipObjects(file: String): List<JSONObject>
    - validateShips(ships: List<JSONObject>):Boolean
    - validateShip(ship:JSONObject): Boolean
    - validateShipUniqueId(id:Int): Boolean
    - validateShipUniqueName(name:String): Boolean
    - validateShipLocation(location: Int): Boolean
    - validateShipAttributes(ship:JSONObject): Boolean
  }

  class ScenarioJSONParser{

    + ScenarioJSONParser(accumulator:Accumulator)
    + parseEvents(json: String)
    + parseGarbage(garbage: String): Garbage
    + validateGarbages(garbages:List<JSONObject>)
    + createGarbage(garbage: JSONObject)
    + validateEvents(events:List<JSONObject>)
    + validateEvent(event: JSONObject)
    + createEvent(event: JSONObject)

    - validateGarbageUniqueId(): Boolean
    - validateGarbageType(): Boolean
    - validateGarbageLocationExists(): Boolean
    - validateGarbageAmount(): Boolean
    - validateEventUniqueId(): Boolean
    - validateEventType(): Boolean
    - validateEventTick(): Boolean
    - validateEventLocation(): Boolean
    - validateEventRadius(): Boolean
    - validateEventSpeed(): Boolean
    - validateEventAmountIfExists(): Boolean
    - validateEventDirectionIfExists(): Boolean
    - validateEventShipIdIfExists(): Boolean

  }

  JSONParser <|-- CorporationJSONParser
  JSONParser <|-- ScenarioJSONParser
  Accumulator --o JSONParser
  class Accumulator {
    +map: Sea
    +corporations: Map<Int, Corporation>
    +ships: Map<Int, Ship>
    +events: Map<Int, Event>
    +garbage: Map<Int, Garbage>
    +mapCorporationToHarbor: Map<Int, List<Tile>>
    +mapCorporationToShips: Map<Int, List<Int>>

    +getHarborsOfCorporation(corporationId:Int):List<Tile>
    +getShipsIDofCorporation(corporationId:Int):List<Int>
    +getTileFromMap(tileId:Int):Tile
    +getTileFromMap(tileCoordinates:Vec2D):Tile
    +addTile(id: Int, t: Tile): Unit
    +addTileByCoordinates(coord: Vec2D, t: Tile): Unit
    +addShip(shipId: Int, ship: Ship)
    +addShipToCorp(corporationId: Int, shipId: Int)
    +getShipsOfCorp(corpId: Int): List<Int>
    +addEvent(eventId: Int, event: Event)
    +addCorporation(corpId: Int, corporation: Corporation)
    +addGarbage(garbageId: Int, garbage: Garbage)

  }
}


package Tiles{
class Vec2D{
  + posX: Int,
  + posY: Int,
  + tilesInRadius(Int): Iterator<Vec2D>
}

class Sea {
  + tiles: List<Tile>
  + tileIndex: Map<Vec2D, Tile>
  + getTileById(Int): Tile
  + getTileByPos(Vec2D): Tile
}

  abstract class Tile{
    - id: Int,
    - pos: Vec2D,
    - adjacentTiles: Tile[6],
    - shipTraversable: Boolean,
    - garbage: List<Garbage>
    ' Stores the amount of garbage drifted to this tile this tick.
    ' This is important because the garbage drifts to the next tile
    ' and we want to drift only as much as the current allows,
    ' but on the other hand we don't want to drift garbage twice.
    ' So we drift each piece of garbage instead of drifting from
    ' within the tick, and this field actually stores the amount
    ' to make sure that we don't drift more than the capacity
    + amountOfGarbageDriftedThisTick: Int
    +Tile(id: Int, pos: Vec2D, shipTraversable: Boolean): Tile
    + isSpaceAvailable(Int): Boolean
    + driftGarbage(GarbageType, Int): Unit
    + getTileInDirection(distance: Int, dir: Direction): Tile
    + addGarbage(g: Garbage): Unit
    + isOilPresent(): Boolean
    + isPlasticPresent(): Boolean
    + areChemicalsPresent(): Boolean
  }


  class Garbage {
    -id: Int,
    -amount: Int,
    -type: GarbageType,
    -static maxId: Int,
    +drift(Tile): Unit
    +static getNextId(): Int
    +canDriftAtOnce(Int): Boolean
    +removeAmount(Int): Unit
  }

  Garbage --> Tile

  Shore --|> Tile
  DeepOcean --|> Tile
  ShallowOcean --|> Tile

  class Current {
    - speed: Int,
    - direction: Direction,
    - intensity: Int,
    + getSpeed(): Int
    + getIntensity(): Int
    + getDirection(): Direction
  }
  class Shore{
    + hasHarbor: boolean
  }
  class ShallowOcean{}
  class DeepOcean{
    - current: Current?
    + getCurrent(): Current?
  }
Current --o DeepOcean
}
'Ships
package Ships{
  abstract class Ship {
    - id: Int,
    - name: String,
    - owner: Corporation,
    - pos: Tile,
    - dir: Direction,
    - maxVelocity: Int,
    - acceleration: Int,
    - fuelCapacity: Int,
    - fuelConsumption: Int,
    - destinationTile: Tile,
    + setDestinationTile(Tile): Unit
    + refuel(): Unit
    + drift(): Unit
    + setTile(Tile): Unit
  }

  ScoutingShip --|> Ship
  CoordinatingShip --|> Ship
  CollectingShip --|> Ship

  class ScoutingShip{
   - visibleRange: Int
   + getTilesWithGarbageInFoV(): List<Tile>
  }
  class CoordinatingShip{
  - visibleRange: Int,
  + getImmediateTilesWithGarbage(): List<Tile>
  }
  class CollectingShip{
   - visibleRange: Int,
   - garbageType: GarbageType
   - garbageCapacity: Int,
   - garbageLoad: Int,
   + giveGarbage(): Unit
  }
}
package Loggers{
  class Logger{
'  - writer: PrintWriter = new PrintWriter(System.out)
    - writer: PrintWriter
    + logInitializationInfoSuccess(filename:String): Unit
    + logInitializationInfoFail(filename:String): Unit
    + logSimulationStarted(): Unit
    + logSimulationEnded(): Unit
    + logSimulationTick(tick:Int): Unit
    + logCorporationStartMoveShips(corporationId:Int): Unit
    + logShipMovement(shipId:Int,speed:Int,tileId:Int): Unit
    + logCorporationStartCollectGarbage(corporateId): Unit
    + logGarbageCollectionByShip(shipId:Int,garbageType:GarbageType,garbageId:Int): Unit
    + logCorporationCooperationStart(corporationId:Int): Unit
    + logCooperationBetweenCorporations(corporationId:Int, otherCorporationId: Int, shipId:Int, cooperatedShipId: Int): Unit
    + logCorporationRefueling(corporationId:Int): Unit
    + logRefuelingShip(shipId:Int, tileId: Int): Unit
    + logUnloadShip(shipId:Int, amount:Int, garbageType:GarbageType, tileId:Int): Unit
    + logCorporationFinishedActions(corporationId:Int): Unit
    + logCurrentDriftGarbage(garbageType:GarbageType, garbageId:Int, amount:Int, startTileId:Int, endTileId:Int): Unit
    + logCurrentDriftShip(shipId:Int,startTileId:Int, endTileId:Int): Unit
    + logEventStart(eventId:Int,eventType:EventType): Unit
    + logSimulationStatisticsCalculated(): Unit
    + logSimulationStatistics(): Unit
  }
}
@enduml